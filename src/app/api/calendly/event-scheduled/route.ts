// /api/calendly/event-scheduled/route.ts - FINAL VERSION
export const runtime = "nodejs";

import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

// Func»õie pentru crearea unei camere Daily.co
async function createDailyRoom(
  sessionId: string,
  endTime: Date
): Promise<{
  roomUrl: string;
  roomName: string;
  roomId: string;
  domainName: string;
}> {
  if (!process.env.DAILY_API_KEY) {
    throw new Error('DAILY_API_KEY is required');
  }
  const dailyApiKey = process.env.DAILY_API_KEY;
  const dailyDomain = process.env.DAILY_DOMAIN ?? 'mysticgold.daily.co';

  // 1. caluleazƒÉ timestamp-ul de expirare
  const exp = Math.floor(endTime.getTime() / 1000);

  // 2. configurarea camerei (fƒÉrƒÉ recording_layout)
  const roomProperties = {
    enable_recording: 'cloud',
    max_participants: 10,
    enable_chat: true,
    enable_screenshare: true,
    start_video_off: false,
    start_audio_off: false,
    exp,
    eject_at_room_exp: true,
    enable_prejoin_ui: true,
    enable_network_ui: true,
    enable_people_ui: true,
    lang: 'en',
    geo: 'auto',
  };

  // helper pentru POST-uri
  const apiPost = async (path: string, body: any) => {
    const res = await fetch(`https://api.daily.co/v1/${path}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${dailyApiKey}`,
      },
      body: JSON.stringify(body),
    });
    if (!res.ok) {
      const text = await res.text();
      throw new Error(`Daily API error (${path}): ${text}`);
    }
    return res.json();
  };

  // 3. creare camerƒÉ
  const room = await apiPost('rooms', {
    name: `calendly-session-${sessionId}`,
    privacy: 'private',
    properties: roomProperties,
  });

  // 4. creare token cu √Ænregistrare automatƒÉ »ôi layout
  const { token } = await apiPost('meeting-tokens', {
    properties: {
      room_name: room.name,
      exp: Math.floor(Date.now() / 1000) + 24 * 3600,
      eject_at_token_exp: true,
      enable_recording: 'cloud',
      start_cloud_recording: true,
      start_cloud_recording_opts: {
        layout: { preset: 'active-speaker' },
      },
    },
  });

  // 5. returneazƒÉ URL-ul cu token
  return {
    roomUrl: `${room.url}?t=${token}`,
    roomName: room.name,
    roomId: room.id,
    domainName: room.domain_name ?? dailyDomain,
  };
}

// üÜï Func»õie pentru validarea »ôi ob»õinerea pachetului
async function validateUserPackage(packageId: string, userId: string, providerId: string) {
  console.log(`üîç Validare pachet: ${packageId} pentru user ${userId} »ôi provider ${providerId}`);
  
  const userPackage = await prisma.userProviderPackage.findFirst({
    where: {
      id: packageId,
      userId: userId,
      providerId: providerId,
    },
    include: {
      providerPackage: {
        select: {
          service: true,
          price: true
        }
      },
      provider: {
        select: {
          mainSpecialityId: true,
          user: {
            select: {
              name: true,
              email: true
            }
          }
        }
      },
      _count: {
        select: {
          sessions: {
            where: {
              wasPackageSession: true,
              status: {
                not: 'CANCELLED'
              }
            }
          }
        }
      }
    }
  });

  if (!userPackage) {
    console.error(`‚ùå Pachetul ${packageId} nu a fost gƒÉsit sau nu apar»õine user-ului ${userId}`);
    throw new Error('Pachetul nu a fost gƒÉsit sau nu vƒÉ apar»õine');
  }

  const actualUsedSessions = userPackage._count.sessions;
  const remainingSessions = userPackage.totalSessions - actualUsedSessions;

  console.log(`üìä Statistici pachet: ${actualUsedSessions}/${userPackage.totalSessions} sesiuni folosite, ${remainingSessions} rƒÉmase`);

  if (remainingSessions <= 0) {
    console.error(`‚ùå Pachetul ${packageId} nu mai are sesiuni disponibile (${actualUsedSessions}/${userPackage.totalSessions})`);
    throw new Error('Pachetul nu mai are sesiuni disponibile');
  }

  if (userPackage.expiresAt && userPackage.expiresAt < new Date()) {
    console.error(`‚ùå Pachetul ${packageId} a expirat la ${userPackage.expiresAt}`);
    throw new Error('Pachetul a expirat');
  }

  console.log(`‚úÖ Pachet valid: ${userPackage.providerPackage?.service} - ${remainingSessions} sesiuni rƒÉmase`);
  
  return {
    userPackage,
    actualUsedSessions,
    remainingSessions
  };
}

export async function POST(request: Request) {
  try {
    console.log('üìÖ Procesare eveniment Calendly cu pachete');

    // AUTENTIFICARE OBLIGATORIE - ia utilizatorul curent
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      console.error('‚ùå Unauthorized: No authenticated user');
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    const currentUserId = session.user.id;
    console.log(`üë§ Client autentificat: ${currentUserId}`);

    // üÜï ParseazƒÉ datele cu packageId
    const { providerId, scheduledEventUri, packageId } = await request.json();

    console.log(`üìä Calendly event data:`, { 
      providerId, 
      scheduledEventUri, 
      packageId, // üÜï 
      clientId: currentUserId 
    });

    // VALIDARE INPUT
    if (!providerId) {
      console.error('‚ùå providerId lipse»ôte');
      return NextResponse.json(
        { error: 'providerId este obligatoriu' },
        { status: 400 }
      );
    }

    if (!scheduledEventUri) {
      console.error('‚ùå scheduledEventUri lipse»ôte');
      return NextResponse.json(
        { error: 'scheduledEventUri este obligatoriu' },
        { status: 400 }
      );
    }

    // üÜï Validare packageId
    if (!packageId) {
      console.error('‚ùå packageId lipse»ôte');
      return NextResponse.json(
        { error: 'packageId este obligatoriu pentru programare' },
        { status: 400 }
      );
    }

    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // √éNCARCƒÇ PROVIDER-UL CU TOKEN-URILE CALENDLY
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    console.log(`üîç CƒÉutare provider cu token-uri Calendly: ${providerId}`);
    
    const provider = await prisma.provider.findUnique({
      where: { userId: providerId },
      select: {
        id: true,
        userId: true,
        calendlyAccessToken: true,
        calendlyRefreshToken: true,
        calendlyExpiresAt: true,
        mainSpeciality: {
          select: {
            id: true,
            name: true,
            price: true,
          }
        },
        user: {
          select: {
            id: true,
            name: true,
            email: true,
          }
        }
      }
    });

    if (!provider) {
      console.error(`‚ùå Provider-ul cu ID ${providerId} nu a fost gƒÉsit`);
      return NextResponse.json(
        { error: `Provider-ul cu ID ${providerId} nu a fost gƒÉsit` },
        { status: 404 }
      );
    }

    if (!provider.mainSpeciality) {
      console.error(`‚ùå Provider-ul ${providerId} nu are specialitate principalƒÉ configuratƒÉ`);
      return NextResponse.json(
        { error: 'Provider-ul nu are o specialitate principalƒÉ configuratƒÉ' },
        { status: 400 }
      );
    }

    // VerificƒÉ cƒÉ provider-ul are token-uri Calendly
    let {
      calendlyAccessToken: token,
      calendlyRefreshToken: refreshToken,
      calendlyExpiresAt: expiresAt,
    } = provider;

    if (!token) {
      console.error(`‚ùå Provider-ul ${providerId} nu are token Calendly configurat`);
      return NextResponse.json(
        { error: 'Provider-ul nu are autentificare Calendly configuratƒÉ' },
        { status: 400 }
      );
    }

    console.log(`‚úÖ Provider gƒÉsit: ${provider.user.name || provider.user.email} (${provider.id})`);
    console.log(`‚úÖ Specialitate: ${provider.mainSpeciality.name}`);

    // üÜï VALIDEAZƒÇ PACHETUL √éNAINTE DE CALENDLY
    console.log('üîç Validare pachet...');
    const { userPackage, actualUsedSessions, remainingSessions } = await validateUserPackage(
      packageId, 
      currentUserId, 
      provider.id
    );

    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // REFRESH TOKEN HELPER
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    async function refreshCalendlyToken(): Promise<boolean> {
      if (!refreshToken) {
        console.warn('‚ö†Ô∏è Nu existƒÉ refresh token pentru provider');
        return false;
      }
      
      if (expiresAt && new Date() < expiresAt) {
        console.log('‚úÖ Token-ul Calendly este √ÆncƒÉ valid');
        return false; // Nu e nevoie de refresh
      }

      console.log('üîÑ Refresh token Calendly...');
      
      const params = new URLSearchParams({
        grant_type: "refresh_token",
        client_id: process.env.NEXT_PUBLIC_CALENDLY_CLIENT_ID!,
        client_secret: process.env.CALENDLY_CLIENT_SECRET!,
        refresh_token: refreshToken,
      });

      const response = await fetch("https://auth.calendly.com/oauth/token", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: params.toString(),
      });

      if (!response.ok) {
        console.error('‚ùå Refresh token failed:', response.statusText);
        return false;
      }

      const tokenData = await response.json();
      
      // ActualizeazƒÉ variabilele locale
      token = tokenData.access_token;
      refreshToken = tokenData.refresh_token;
      expiresAt = new Date(Date.now() + tokenData.expires_in * 1000);

      // SalveazƒÉ √Æn baza de date
      await prisma.provider.update({
        where: { id: provider.id },
        data: {
          calendlyAccessToken: token,
          calendlyRefreshToken: refreshToken,
          calendlyExpiresAt: expiresAt,
        },
      });

      console.log('‚úÖ Token Calendly actualizat cu succes');
      return true;
    }

    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    // OB»öINE DETALIILE EVENIMENTULUI CALENDLY
    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
    console.log('üìû Ob»õinere detalii eveniment Calendly...');
    
    let response = await fetch(scheduledEventUri, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
    });

    // DacƒÉ primim 401, √ÆncearcƒÉ sƒÉ re√ÆmprospƒÉtezi token-ul
    if (response.status === 401) {
      console.log('üîÑ Token expirat, √Æncerc refresh...');
      const refreshed = await refreshCalendlyToken();
      
      if (refreshed) {
        response = await fetch(scheduledEventUri, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
          },
        });
      }
    }

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Eroare la ob»õinerea detaliilor Calendly:', errorText);
      throw new Error(`Failed to fetch Calendly event: ${response.statusText}`);
    }

    const eventDetails = await response.json();
    const eventData = eventDetails.resource;

    // Extrage informa»õiile necesare
    const startTime = new Date(eventData.start_time);
    const endTime = new Date(eventData.end_time);
    const clientEmail = eventData.event_memberships?.[0]?.user_email;
    const clientName = eventData.event_memberships?.[0]?.user_name;

    console.log(`‚è∞ Timp programat: ${startTime.toISOString()} - ${endTime.toISOString()}`);
    console.log(`üìß Client din Calendly: ${clientName} (${clientEmail})`);

    // VerificƒÉ cƒÉ utilizatorul curent existƒÉ √Æn baza de date
    console.log(`üîç Verificare utilizator curent: ${currentUserId}`);
    
    const clientUser = await prisma.user.findUnique({
      where: { id: currentUserId },
      select: { id: true, name: true, email: true, role: true }
    });

    if (!clientUser) {
      console.error(`‚ùå Utilizatorul autentificat ${currentUserId} nu existƒÉ √Æn baza de date`);
      return NextResponse.json(
        { error: 'Utilizatorul autentificat nu a fost gƒÉsit √Æn baza de date' },
        { status: 404 }
      );
    }

    console.log(`‚úÖ Client confirmat: ${clientUser.name || clientUser.email} (${clientUser.id}) - Role: ${clientUser.role}`);

    // VerificƒÉ cƒÉ clientul »ôi provider-ul sunt diferi»õi
    if (clientUser.id === provider.userId) {
      console.error(`‚ùå Clientul ${clientUser.id} »ôi provider-ul ${provider.userId} sunt aceea»ôi persoanƒÉ`);
      return NextResponse.json(
        { error: 'Nu vƒÉ pute»õi programa o sesiune cu dvs. √Ænsu»ôi' },
        { status: 400 }
      );
    }

    // VerificƒÉ dacƒÉ email-ul din Calendly se potrive»ôte cu utilizatorul autentificat (op»õional)
    if (clientEmail && clientUser.email && clientEmail.toLowerCase() !== clientUser.email.toLowerCase()) {
      console.warn(`‚ö†Ô∏è Email-ul din Calendly (${clientEmail}) diferƒÉ de email-ul utilizatorului autentificat (${clientUser.email})`);
      // Log warning dar continuƒÉ - poate utilizatorul a folosit alt email √Æn Calendly
    }

    // GenereazƒÉ un ID unic pentru sesiune
    const sessionId = `calendly_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    console.log(`üÜî ID sesiune generat: ${sessionId}`);

    // CreeazƒÉ camera Daily.co
    console.log('üé• Creare camerƒÉ Daily.co...');
    const dailyRoom = await createDailyRoom(sessionId, endTime);

    // CalculeazƒÉ durata estimatƒÉ (√Æn minute)
    const estimatedDuration = Math.round(
      (endTime.getTime() - startTime.getTime()) / (1000 * 60)
    );

    // üÜï CREEAZƒÇ SESIUNEA √éN TRANZAC»öIE CU PACHETE »òI INCREMENTAREA SESIUNILOR FOLOSITE
    console.log('üíæ Salvare sesiune √Æn baza de date cu pachete...');
    
    const result = await prisma.$transaction(async (tx) => {
      // VerificƒÉ din nou disponibilitatea pachetului √Æn tranzac»õie (pentru concuren»õƒÉ)
      const currentPackage = await tx.userProviderPackage.findUnique({
        where: { id: packageId },
        include: {
          _count: {
            select: {
              sessions: {
                where: {
                  wasPackageSession: true,
                  status: { not: 'CANCELLED' }
                }
              }
            }
          }
        }
      });

      if (!currentPackage) {
        console.error(`‚ùå Pachetul ${packageId} nu mai existƒÉ`);
        throw new Error('Pachetul nu mai existƒÉ');
      }

      const currentUsedSessions = currentPackage._count.sessions;
      if (currentUsedSessions >= currentPackage.totalSessions) {
        console.error(`‚ùå Pachetul ${packageId} nu mai are sesiuni disponibile √Æn tranzac»õie (${currentUsedSessions}/${currentPackage.totalSessions})`);
        throw new Error('Pachetul nu mai are sesiuni disponibile');
      }

      // CalculeazƒÉ numƒÉrul sesiunii √Æn pachet
      const sessionNumber = currentUsedSessions + 1;

      console.log(`üìù Creez sesiunea #${sessionNumber} din pachetul ${userPackage.providerPackage?.service}`);

      // CreeazƒÉ sesiunea de consultan»õƒÉ cu toate detaliile
      const sessionRecord = await tx.consultingSession.create({
        data: {
          id: sessionId,
          providerId: provider.id,
          clientId: clientUser.id,
          specialityId: provider.mainSpeciality.id,
          
          // üÜï Detalii pachete
          packageId: packageId,
          wasPackageSession: true,
          packageSessionNumber: sessionNumber,
          
          // Daily.co details
          dailyRoomName: dailyRoom.roomName,
          dailyRoomUrl: dailyRoom.roomUrl,
          dailyRoomId: dailyRoom.roomId,
          dailyDomainName: dailyRoom.domainName,
          dailyCreatedAt: new Date(),
          
          // Session details
          startDate: startTime,
          endDate: endTime,
          duration: estimatedDuration,
          calendlyEventUri: scheduledEventUri,
          scheduledAt: new Date(),
          status: 'SCHEDULED',
          
          totalPrice: Math.round(provider.mainSpeciality.price * 100), // √Æn bani
          notes: `Sesiune #${sessionNumber} din pachetul ${userPackage.providerPackage?.service}. ProgramatƒÉ prin Calendly pentru ${clientUser.name || clientUser.email}. Calendly client: ${clientName} (${clientEmail})`,
          createdAt: new Date(),
          updatedAt: new Date(),
        }
      });

      // üÜï INCREMENTEAZƒÇ SESIUNILE FOLOSITE √éN PACHET
      const updatedPackage = await tx.userProviderPackage.update({
        where: { id: packageId },
        data: {
          usedSessions: { increment: 1 }
        }
      });

      console.log(`üìä Incrementat usedSessions pentru pachetul ${packageId}: ${currentPackage.usedSessions} ‚Üí ${updatedPackage.usedSessions}`);

      return {
        session: sessionRecord,
        packageInfo: {
          sessionNumber,
          remainingSessions: remainingSessions - 1,
          totalSessions: userPackage.totalSessions,
          packageName: userPackage.providerPackage?.service,
          packageId: packageId,
          usedSessions: updatedPackage.usedSessions,
          oldUsedSessions: currentPackage.usedSessions
        }
      };
    });

    console.log(`‚úÖ »òedin»õƒÉ salvatƒÉ cu succes din pachet:`);
    console.log(`   - ID: ${sessionId}`);
    console.log(`   - Client: ${clientUser.name || clientUser.email} (${clientUser.id})`);
    console.log(`   - Provider: ${provider.user.name || provider.user.email} (${provider.id})`);
    console.log(`   - Specialitate: ${provider.mainSpeciality.name}`);
    console.log(`   - Camera Daily.co: ${dailyRoom.roomUrl}`);
    console.log(`   - Timp: ${startTime.toISOString()}`);
    console.log(`   - üÜï Pachet: ${result.packageInfo.packageName} (sesiunea #${result.packageInfo.sessionNumber})`);
    console.log(`   - üÜï Sesiuni folosite: ${result.packageInfo.oldUsedSessions} ‚Üí ${result.packageInfo.usedSessions}`);
    console.log(`   - üÜï Sesiuni rƒÉmase: ${result.packageInfo.remainingSessions}`);

    return NextResponse.json({
      success: true,
      sessionId: result.session.id,
      roomUrl: result.session.dailyRoomUrl,
      joinUrl: `/servicii/video/sessions/${result.session.id}`,
      message: `Sesiunea #${result.packageInfo.sessionNumber} a fost programatƒÉ cu succes din pachetul ${result.packageInfo.packageName}!`,
      details: {
        sessionId: result.session.id,
        startDate: result.session.startDate?.toISOString(),
        endDate: result.session.endDate?.toISOString(),
        duration: result.session.duration,
        speciality: provider.mainSpeciality.name,
        
        // üÜï Informa»õii pachete
        packageInfo: result.packageInfo,
        
        client: {
          id: clientUser.id,
          name: clientUser.name || clientUser.email,
          email: clientUser.email,
          role: clientUser.role
        },
        provider: {
          id: provider.id,
          name: provider.user.name || provider.user.email,
          email: provider.user.email
        },
        dailyRoom: {
          roomName: dailyRoom.roomName,
          roomUrl: dailyRoom.roomUrl,
          roomId: dailyRoom.roomId,
          domainName: dailyRoom.domainName
        },
        calendlyEvent: {
          uri: scheduledEventUri,
          clientName: clientName,
          clientEmail: clientEmail
        }
      }
    });

  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    console.error('‚ùå Eroare la salvarea »ôedin»õei din Calendly cu pachete:', message);
    console.error('Stack trace:', err instanceof Error ? err.stack : 'N/A');
    
    // üÜï ReturneazƒÉ erori specifice pentru pachete
    if (message.includes('Pachetul nu mai are sesiuni') || message.includes('nu apar»õine')) {
      return NextResponse.json(
        { 
          error: 'Package validation failed',
          message: message,
          code: 'PACKAGE_ERROR'
        },
        { status: 409 }
      );
    }

    if (message.includes('expirat')) {
      return NextResponse.json(
        { 
          error: 'Package expired',
          message: message,
          code: 'PACKAGE_EXPIRED'
        },
        { status: 410 }
      );
    }
    
    // ReturneazƒÉ erori mai specifice bazate pe tipul erorii
    if (message.includes('Daily.co') || message.includes('DAILY_API_KEY')) {
      return NextResponse.json(
        { 
          error: 'Video room creation failed',
          message: 'Unable to create video room. Please try again later.',
          code: 'DAILY_ERROR'
        },
        { status: 503 }
      );
    }

    if (message.includes('Calendly') || message.includes('CALENDLY')) {
      return NextResponse.json(
        { 
          error: 'Calendly integration error',
          message: 'Unable to fetch event details from Calendly. Please check provider Calendly configuration.',
          code: 'CALENDLY_ERROR'
        },
        { status: 502 }
      );
    }

    return NextResponse.json(
      { 
        error: 'Session creation failed',
        message: 'An unexpected error occurred while creating your session.',
        code: 'UNKNOWN_ERROR',
        details: process.env.NODE_ENV === 'development' ? message : undefined
      },
      { status: 500 }
    );
  }
}