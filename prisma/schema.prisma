generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  STANDARD
}

enum Service {
  CHAT
  MEET
}

enum ApprovalType {
  SPECIALITY
  TOOL
  READING
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

/// Tipul de entitate pentru facturare
enum EntityType {
  PERS_FIZICA
  PERS_JURIDICA
}

enum MessageType {
  GLOBAL   // chat global
  PRIVATE  // conversa탵ii private
}

/// Status pentru sesiunile de consultan탵캒
enum SessionStatus {
  SCHEDULED    // programat캒
  IN_PROGRESS  // 칥n desf캒탳urare
  COMPLETED    // finalizat캒
  CANCELLED    // anulat캒
  NO_SHOW      // client nu s-a prezentat
}

model Message {
  id           String      @id @default(uuid())
  content      String
  
  // Pentru conversa탵ii private
  fromUsername String?     // expeditorul mesajului
  toUsername   String?     // destinatarul mesajului
  
  // Pentru chat global (backwards compatibility)
  username     String?     // pentru mesajele globale existente
  
  // Tip de mesaj pentru a face diferen탵a
  messageType  MessageType @default(PRIVATE)
  
  createdAt    DateTime    @default(now()) @map("created_at")

  @@map("messages")
  @@index([fromUsername, toUsername])
  @@index([messageType])
}

model BillingDetails {
  id          String     @id @default(uuid())
  userId      String     @unique
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// Persoan캒 fizic캒 = nume complet + CNP  
  /// Persoan캒 juridic캒 = firm캒 + CIF
  entityType  EntityType @default(PERS_JURIDICA)

  // Pentru ambele tipuri
  companyName String     // pentru PF = nume complet, pentru PJ = firm캒
  cif         String     // pentru PF = CNP, pentru PJ = CIF
  address     String
  phone       String

  // Doar pentru PJ
  bank        String?    // devine NULL pentru PF
  iban        String?    // devine NULL pentru PF

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@map("billing_details")
}

model User {
  id                 String             @id @default(uuid())
  name               String?            @unique
  email              String?            @unique
  emailVerified      Boolean?           @default(false)
  image              String?
  password           String?
  birthDate          DateTime?
  gender             String?
  role               Role               @default(STANDARD)
  passwordResets     PasswordReset[]
  consultingSessions ConsultingSession[] @relation("ClientSessions")
  accounts           Account[]
  sessions           Session[]          @relation("UserSessions")
  provider           Provider?          @relation("UserToProvider")
  reviewsFrom        Review[]           @relation("ReviewFromUser")
  groupUsers         GroupUsers[]
  chatGroups         ChatGroup[]
  providerPackages   UserProviderPackage[] @relation("UserPackages")
  emailVerification  EmailVerification? @relation("UserEmailVerification")

  // rela탵ii pentru ApprovalRequest
  requestsCreated    ApprovalRequest[]  @relation("RequestsCreated")
  requestsReviewed   ApprovalRequest[]  @relation("RequestsReviewed")

  billingDetails    BillingDetails?   // rela콖ie 1-la-1 f캒r캒 @relation aici
}

model ApprovalRequest {
  id           String           @id @default(uuid())
  type         ApprovalType
  name         String
  description  String?
  price        Float?
  createdById  String
  createdBy    User             @relation("RequestsCreated", fields: [createdById], references: [id], onDelete: Cascade)

  status       ApprovalStatus   @default(PENDING)

  reviewedById String?
  reviewedBy   User?            @relation("RequestsReviewed", fields: [reviewedById], references: [id], onDelete: SetNull)

  createdAt    DateTime         @default(now())
  reviewedAt   DateTime?
}

model Provider {
  id                     String                   @id @default(uuid())
  userId                 String                   @unique
  user                   User                     @relation("UserToProvider", fields: [userId], references: [id], onDelete: Cascade)
  stripeAccountId        String?      @unique
  online                 Boolean                  @default(false)
  description            String?
  videoUrl               String?
  grossVolume            Float?                   @default(0)

  /// URI-ul unic al calendarului Calendly (seat-ul provider-ului)
  calendlyCalendarUri    String?                  @unique
  calendlyAccessToken  String?  // access token (Bearer) pe care 칥l prime탳ti la OAuth
  calendlyRefreshToken String?  // dac캒 vrei s캒 faci refresh
  calendlyExpiresAt    DateTime?// c칙nd expir캒 access_token-ul
  calendlyUserUri      String?
  isCalendlyConnected   Boolean  @default(false)
  readingId              String?
  reading                Reading?                 @relation("ProviderReading", fields: [readingId], references: [id], onDelete: SetNull)

  specialities           Speciality[]             @relation("ProviderSpecialities")
  tools                  Tool[]                   @relation("ProviderTools")
  mainSpecialityId       String?
  mainSpeciality         Speciality?              @relation("ProviderMainSpeciality", fields: [mainSpecialityId], references: [id])
  mainToolId             String?
  mainTool               Tool?                    @relation("ProviderMainTool", fields: [mainToolId], references: [id])
  reviews                Review[]                 @relation("ReviewForProvider")
  sessions               ConsultingSession[]      @relation("ProviderSessions")
  providerPackages       ProviderPackage[]        @relation("ProviderPkg")
  userProviderPackages   UserProviderPackage[]    @relation("UserProviderPkgs")

  /// Rela탵ie c캒tre subscrip탵iile webhook Calendly
  calendlySubscriptions  CalendlyWebhookSubscription[] @relation("ProviderCalendlyWebhooks")
}

model ProviderPackage {
  id             String                  @id @default(uuid())
  providerId     String
  service        String
  totalSessions  Int
  price          Float
  createdAt      DateTime                @default(now())
  expiresAt      DateTime?
  calendlyEventTypeUri String? @unique
  provider       Provider                @relation("ProviderPkg", fields: [providerId], references: [id], onDelete: Cascade)
  userProviderPackages UserProviderPackage[] @relation("ProviderPackageUsers")
}

model UserProviderPackage {
  id               String                  @id @default(uuid())
  userId           String
  providerId       String
  packageId        String
  totalSessions    Int
  usedSessions     Int                     @default(0)
  createdAt        DateTime                @default(now())
  expiresAt        DateTime?

  user             User                    @relation("UserPackages", fields: [userId], references: [id], onDelete: Cascade)
  provider         Provider                @relation("UserProviderPkgs", fields: [providerId], references: [id], onDelete: Cascade)
  providerPackage  ProviderPackage         @relation("ProviderPackageUsers", fields: [packageId], references: [id], onDelete: Cascade)
  sessions         ConsultingSession[]     @relation("SessionUserPackage")
  invoices         Invoice[]               @relation("PackageInvoices")

  // 游 Index-uri optimizate pentru c캒utarea pachetelor disponibile
  @@index([userId, providerId, usedSessions, expiresAt])  // pentru getAvailablePackages()
  @@index([usedSessions, totalSessions])                  // pentru filtrarea rapid캒
  @@index([expiresAt])                                    // pentru g캒sirea celor care expir캒
}

model Invoice {
  id            String                 @id @default(uuid())
  number        String                 // num캒rul facturii (din Oblio)
  url           String                 // URL-ul PDF-ului salvat
  createdAt     DateTime               @default(now())
  packageId     String
  package       UserProviderPackage    @relation("PackageInvoices", fields: [packageId], references: [id], onDelete: Cascade)

  @@index([packageId])
}

model Reading {
  id          String         @id @default(uuid())
  name        String
  description String?
  providers   Provider[]     @relation("ProviderReading")
}

model Speciality {
  id          String               @id @default(uuid())
  name        String
  description String?
  price       Float

  providers   Provider[]           @relation("ProviderSpecialities")
  mainFor     Provider[]           @relation("ProviderMainSpeciality")
  sessions    ConsultingSession[]  @relation("SpecialitySessions")
}

model Tool {
  id               String     @id @default(uuid())
  name             String
  description      String?

  providers        Provider[] @relation("ProviderTools")
  mainForProviders Provider[] @relation("ProviderMainTool")
}

// Doar partea ConsultingSession actualizat캒 din schema.prisma
// 칉nlocuie탳te modelul ConsultingSession existent cu aceast캒 versiune

model ConsultingSession {
  id               String                  @id @default(uuid())
  providerId       String
  clientId         String
  specialityId     String
  packageId        String?
  duration         Int?

  // Daily.co integration (칥nlocuie탳te Zoom)
  dailyRoomName    String?                 @unique // numele camerei Daily.co
  dailyRoomUrl     String?                 // URL-ul complet al camerei Daily.co
  dailyRoomId      String?                 // ID-ul intern Daily.co
  dailyRoomConfig  Json?                   // configur캒ri specifice pentru camer캒
  dailyCreatedAt   DateTime?               // c칙nd a fost creat캒 camera Daily.co
  dailyDomainName  String?                 // domeniul Daily.co folosit

  // Session management
  status           SessionStatus           @default(SCHEDULED)
  joinedAt         DateTime?               // c칙nd s-a al캒turat clientul
  leftAt           DateTime?               // c칙nd a p캒r캒sit ultima persoan캒
  actualDuration   Int?                    // durata real캒 칥n minute

  // Calendly integration (p캒strat)
  calendlyEventUri String?                 // URI-ul evenimentului Calendly
  scheduledAt      DateTime?               // c칙nd a fost programat캒

  // Session details
  startDate        DateTime?               // data/ora programat캒
  endDate          DateTime?               // data/ora de sf칙r탳it
  totalPrice       Int?
  isFinished       Boolean                 @default(false)

  // Session tracking 탳i analytics
  participantCount Int?                    @default(0) // num캒rul de participan탵i care s-au al캒turat
  recordingUrl     String?                 // URL-ul record캒rii (dac캒 exist캒)
  notes            String?                 // noti탵e post-sesiune
  rating           Float?                  // rating dat de client
  feedback         String?                 // feedback text

  // Recording management
  recordingStarted     Boolean   @default(false)  // dac캒 칥nregistrarea e activ캒
  recordingStartedAt   DateTime?                  // c칙nd a 칥nceput 칥nregistrarea
  recordingStoppedAt   DateTime?                  // c칙nd s-a oprit 칥nregistrarea
  hasRecording         Boolean   @default(false)  // dac캒 sesiunea are 칥nregistrare
  recordingDuration    Int?                       // durata 칥nregistr캒rii 칥n minute
  recordingFileSize    BigInt?                    // m캒rimea fi탳ierului 칥n bytes
  recordingStatus      String?                    // statusul proces캒rii ("PROCESSING", "READY", etc.)
  endedBy              String?                    // ID-ul user-ului care a 칥nchis sesiunea

  // 游 C칙mpuri noi pentru tracking pachete
  wasPackageSession    Boolean   @default(false)  // dac캒 sesiunea a fost pl캒tit캒 prin pachet
  packageSessionNumber Int?                       // num캒rul sesiunii din pachet (1, 2, 3...)

  // Rela탵ii
  provider         Provider                @relation("ProviderSessions", fields: [providerId], references: [id], onDelete: Cascade)
  client           User                    @relation("ClientSessions", fields: [clientId], references: [id], onDelete: Cascade)
  sessionAccount   Account?                @relation("SessionAccount", fields: [accountId], references: [id], onDelete: SetNull)
  speciality       Speciality              @relation("SpecialitySessions", fields: [specialityId], references: [id], onDelete: Cascade)
  userPackage      UserProviderPackage?    @relation("SessionUserPackage", fields: [packageId], references: [id])

  // Legacy fields pentru compatibilitate (pot fi eliminate dup캒 migrare)
  accountId        Int?
  zoomSessionName  String?                 
  zoomTokens       Json?
  zoomCreatedAt    DateTime?
  zoomSessionId    String?

  // Timestamps cu valori default
  createdAt        DateTime                @default(now())
  updatedAt        DateTime                @default(now()) @updatedAt

  // Index-uri optimizate
  @@index([status])
  @@index([startDate])
  @@index([providerId, clientId])
  @@index([dailyRoomName])
  @@index([packageId, status])           // 游 pentru c캒ut캒ri rapide dup캒 pachet 탳i status
  @@index([wasPackageSession])           // 游 pentru filtrarea sesiunilor din pachete
  @@index([scheduledAt])                 // 游 pentru sortarea cronologic캒

  @@map("ConsultingSession")
}

model Review {
  id           String    @id @default(uuid())
  comment      String?
  date         DateTime
  rating       Float
  service      Service   @default(MEET)

  fromUserId   String
  fromUser     User      @relation("ReviewFromUser", fields: [fromUserId], references: [id], onDelete: Cascade)
  providerId   String
  provider     Provider  @relation("ReviewForProvider", fields: [providerId], references: [id], onDelete: Cascade)
}

model Account {
  id                 Int                   @id @default(autoincrement())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?               @db.Text
  access_token       String?               @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?               @db.Text
  session_state      String?

  user               User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  accountSessions    ConsultingSession[]   @relation("SessionAccount")

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  user         User     @relation("UserSessions", fields: [userId], references: [id], onDelete: Cascade)
  expires      DateTime
}

model GroupUsers {
  id         Int        @id @default(autoincrement())
  group      ChatGroup  @relation(fields: [group_id], references: [id], onDelete: Cascade)
  group_id   String
  user       User       @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id    String
  createdAt  DateTime   @default(now())
}

model ChatGroup {
  id         String     @id @default(uuid())
  user       User       @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id    String
  name       String
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  groupUsers GroupUsers[]
}

model CalendlyWebhookSubscription {
  id               String    @id @default(uuid())
  subscriptionId   String    @unique
  calendarUri      String
  events           String[]  
  scope            String
  callbackUrl      String
  providerId       String
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  provider         Provider  @relation("ProviderCalendlyWebhooks", fields: [providerId], references: [id], onDelete: Cascade)

  @@index([calendarUri])
}

model EmailVerification {
  id        String   @id @default(uuid())
  userId    String   @unique
  token     String   @unique
  expiresAt DateTime

  user      User     @relation("UserEmailVerification", fields: [userId], references: [id], onDelete: Cascade)
}

model PasswordReset {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
}