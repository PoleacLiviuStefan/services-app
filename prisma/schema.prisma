generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  STANDARD
}

enum Service {
  CHAT
  MEET
}

enum ApprovalType {
  SPECIALITY
  TOOL
  READING
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

/// Tipul de entitate pentru facturare
enum EntityType {
  PERS_FIZICA
  PERS_JURIDICA
}

enum MessageType {
  GLOBAL   // chat global
  PRIVATE  // conversa»õii private
}

/// Status pentru sesiunile de consultan»õƒÉ
enum SessionStatus {
  SCHEDULED    // programatƒÉ
  IN_PROGRESS  // √Æn desfƒÉ»ôurare
  COMPLETED    // finalizatƒÉ
  CANCELLED    // anulatƒÉ
  NO_SHOW      // client nu s-a prezentat
}

model Message {
  id           String      @id @default(uuid())
  content      String
  
  // üÜï Pentru conversa»õii private - folosim slug-uri √Æn loc de nume
  fromUserSlug String?     // slug-ul expeditorului mesajului
  toUserSlug   String?     // slug-ul destinatarului mesajului
  
  // üÜï Pentru chat global - folosim slug √Æn loc de username
  userSlug     String?     // slug-ul pentru mesajele globale
  
  // üóëÔ∏è DEPRECATED - pƒÉstrate pentru backwards compatibility, vor fi eliminate
  fromUsername String?     // DEPRECATED - va fi eliminat dupƒÉ migra»õie
  toUsername   String?     // DEPRECATED - va fi eliminat dupƒÉ migra»õie  
  username     String?     // DEPRECATED - va fi eliminat dupƒÉ migra»õie
  
  // Tip de mesaj pentru a face diferen»õa
  messageType  MessageType @default(PRIVATE)
  
  createdAt    DateTime    @default(now()) @map("created_at")

  @@map("messages")
  
  // üÜï Index-uri actualizate pentru slug-uri
  @@index([fromUserSlug, toUserSlug])
  @@index([userSlug])
  @@index([messageType])
  
  // üóëÔ∏è Index-uri vechi - vor fi eliminate dupƒÉ migra»õie
  @@index([fromUsername, toUsername])
}

model BillingDetails {
  id          String     @id @default(uuid())
  userId      String     @unique
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// PersoanƒÉ fizicƒÉ = nume complet + CNP  
  /// PersoanƒÉ juridicƒÉ = firmƒÉ + CIF
  entityType  EntityType @default(PERS_JURIDICA)

  // Pentru ambele tipuri
  companyName String     // pentru PF = nume complet, pentru PJ = firmƒÉ
  cif         String     // pentru PF = CNP, pentru PJ = CIF
  address     String
  phone       String

  // Doar pentru PJ
  bank        String?    // devine NULL pentru PF
  iban        String?    // devine NULL pentru PF

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@map("billing_details")
}

model User {
  id                 String             @id @default(uuid())
  name               String?            @unique
  slug               String?            @unique     
  email              String?            @unique
  emailVerified      Boolean?           @default(false)
  image              String?
  password           String?
  birthDate          DateTime?
  gender             String?
  role               Role               @default(STANDARD)
  passwordResets     PasswordReset[]
  consultingSessions ConsultingSession[] @relation("ClientSessions")
  accounts           Account[]
  sessions           Session[]          @relation("UserSessions")
  provider           Provider?          @relation("UserToProvider")
  reviewsFrom        Review[]           @relation("ReviewFromUser")
  groupUsers         GroupUsers[]
  chatGroups         ChatGroup[]
  providerPackages   UserProviderPackage[] @relation("UserPackages")
  emailVerification  EmailVerification? @relation("UserEmailVerification")

  // rela»õii pentru ApprovalRequest
  requestsCreated    ApprovalRequest[]  @relation("RequestsCreated")
  requestsReviewed   ApprovalRequest[]  @relation("RequestsReviewed")

  billingDetails    BillingDetails?   // rela≈£ie 1-la-1 fƒÉrƒÉ @relation aici
}

model ApprovalRequest {
  id           String           @id @default(uuid())
  type         ApprovalType
  name         String
  description  String?
  price        Float?
  createdById  String
  createdBy    User             @relation("RequestsCreated", fields: [createdById], references: [id], onDelete: Cascade)

  status       ApprovalStatus   @default(PENDING)

  reviewedById String?
  reviewedBy   User?            @relation("RequestsReviewed", fields: [reviewedById], references: [id], onDelete: SetNull)

  createdAt    DateTime         @default(now())
  reviewedAt   DateTime?
}

model Provider {
  id                     String                   @id @default(uuid())
  userId                 String                   @unique
  user                   User                     @relation("UserToProvider", fields: [userId], references: [id], onDelete: Cascade)
  stripeAccountId        String?      @unique
  online                 Boolean                  @default(false)
  description            String?
  videoUrl               String?
  grossVolume            Float?                   @default(0)

  /// URI-ul unic al calendarului Calendly (seat-ul provider-ului)
  calendlyCalendarUri    String?                  @unique
  calendlyAccessToken  String?  // access token (Bearer) pe care √Æl prime»ôti la OAuth
  calendlyRefreshToken String?  // dacƒÉ vrei sƒÉ faci refresh
  calendlyExpiresAt    DateTime?// c√¢nd expirƒÉ access_token-ul
  calendlyUserUri      String?
  isCalendlyConnected   Boolean  @default(false)
  readingId              String?
  reading                Reading?                 @relation("ProviderReading", fields: [readingId], references: [id], onDelete: SetNull)

  specialities           Speciality[]             @relation("ProviderSpecialities")
  tools                  Tool[]                   @relation("ProviderTools")
  mainSpecialityId       String?
  mainSpeciality         Speciality?              @relation("ProviderMainSpeciality", fields: [mainSpecialityId], references: [id])
  mainToolId             String?
  mainTool               Tool?                    @relation("ProviderMainTool", fields: [mainToolId], references: [id])
  reviews                Review[]                 @relation("ReviewForProvider")
  sessions               ConsultingSession[]      @relation("ProviderSessions")
  providerPackages       ProviderPackage[]        @relation("ProviderPkg")
  userProviderPackages   UserProviderPackage[]    @relation("UserProviderPkgs")

  /// Rela»õie cƒÉtre subscrip»õiile webhook Calendly
  calendlySubscriptions  CalendlyWebhookSubscription[] @relation("ProviderCalendlyWebhooks")
}

model ProviderPackage {
  id             String                  @id @default(uuid())
  providerId     String
  service        String
  totalSessions  Int
  price          Float
  createdAt      DateTime                @default(now())
  expiresAt      DateTime?
  calendlyEventTypeUri String? @unique
  provider       Provider                @relation("ProviderPkg", fields: [providerId], references: [id], onDelete: Cascade)
  userProviderPackages UserProviderPackage[] @relation("ProviderPackageUsers")
}

model UserProviderPackage {
  id               String                  @id @default(uuid())
  userId           String
  providerId       String
  packageId        String
  totalSessions    Int
  usedSessions     Int                     @default(0)
  createdAt        DateTime                @default(now())
  expiresAt        DateTime?

  user             User                    @relation("UserPackages", fields: [userId], references: [id], onDelete: Cascade)
  provider         Provider                @relation("UserProviderPkgs", fields: [providerId], references: [id], onDelete: Cascade)
  providerPackage  ProviderPackage         @relation("ProviderPackageUsers", fields: [packageId], references: [id], onDelete: Cascade)
  sessions         ConsultingSession[]     @relation("SessionUserPackage")
  invoices         Invoice[]               @relation("PackageInvoices")

  // üÜï Index-uri optimizate pentru cƒÉutarea pachetelor disponibile
  @@index([userId, providerId, usedSessions, expiresAt])  // pentru getAvailablePackages()
  @@index([usedSessions, totalSessions])                  // pentru filtrarea rapidƒÉ
  @@index([expiresAt])                                    // pentru gƒÉsirea celor care expirƒÉ
}

model Invoice {
  id            String                 @id @default(uuid())
  number        String                 // numƒÉrul facturii (din Oblio)
  url           String                 // URL-ul PDF-ului salvat
  createdAt     DateTime               @default(now())
  packageId     String
  package       UserProviderPackage    @relation("PackageInvoices", fields: [packageId], references: [id], onDelete: Cascade)

  @@index([packageId])
}

model Reading {
  id          String         @id @default(uuid())
  name        String
  description String?
  providers   Provider[]     @relation("ProviderReading")
}

model Speciality {
  id          String               @id @default(uuid())
  name        String
  description String?
  price       Float

  providers   Provider[]           @relation("ProviderSpecialities")
  mainFor     Provider[]           @relation("ProviderMainSpeciality")
  // üóëÔ∏è ELIMINAT: sessions    ConsultingSession[]  @relation("SpecialitySessions")
}

model Tool {
  id               String     @id @default(uuid())
  name             String
  description      String?

  providers        Provider[] @relation("ProviderTools")
  mainForProviders Provider[] @relation("ProviderMainTool")
}

model ConsultingSession {
  id               String                  @id @default(uuid())
  providerId       String
  clientId         String
  // üóëÔ∏è ELIMINAT: specialityId     String
  packageId        String?
  duration         Int?

  // Daily.co integration (√Ænlocuie»ôte Zoom)
  dailyRoomName    String?                 @unique // numele camerei Daily.co
  dailyRoomUrl     String?                 // URL-ul complet al camerei Daily.co
  dailyRoomId      String?                 // ID-ul intern Daily.co
  dailyRoomConfig  Json?                   // configurƒÉri specifice pentru camerƒÉ
  dailyCreatedAt   DateTime?               // c√¢nd a fost creatƒÉ camera Daily.co
  dailyDomainName  String?                 // domeniul Daily.co folosit

  // Session management
  status           SessionStatus           @default(SCHEDULED)
  joinedAt         DateTime?               // c√¢nd s-a alƒÉturat clientul
  leftAt           DateTime?               // c√¢nd a pƒÉrƒÉsit ultima persoanƒÉ
  actualDuration   Int?                    // durata realƒÉ √Æn minute

  // Calendly integration (pƒÉstrat)
  calendlyEventUri String?                 // URI-ul evenimentului Calendly
  scheduledAt      DateTime?               // c√¢nd a fost programatƒÉ

  // Session details
  startDate        DateTime?               // data/ora programatƒÉ
  endDate          DateTime?               // data/ora de sf√¢r»ôit
  totalPrice       Int?
  isFinished       Boolean                 @default(false)

  // Session tracking »ôi analytics
  participantCount Int?                    @default(0) // numƒÉrul de participan»õi care s-au alƒÉturat
  recordingUrl     String?                 // URL-ul recordƒÉrii (dacƒÉ existƒÉ)
  notes            String?                 // noti»õe post-sesiune
  rating           Float?                  // rating dat de client
  feedback         String?                 // feedback text

  // Recording management
  recordingStarted     Boolean   @default(false)  // dacƒÉ √Ænregistrarea e activƒÉ
  recordingStartedAt   DateTime?                  // c√¢nd a √Ænceput √Ænregistrarea
  recordingStoppedAt   DateTime?                  // c√¢nd s-a oprit √Ænregistrarea
  hasRecording         Boolean   @default(false)  // dacƒÉ sesiunea are √Ænregistrare
  recordingDuration    Int?                       // durata √ÆnregistrƒÉrii √Æn minute
  recordingFileSize    BigInt?                    // mƒÉrimea fi»ôierului √Æn bytes
  recordingStatus      String?                    // statusul procesƒÉrii ("PROCESSING", "READY", etc.)
  endedBy              String?                    // ID-ul user-ului care a √Ænchis sesiunea

  // üÜï C√¢mpuri noi pentru tracking pachete
  wasPackageSession    Boolean   @default(false)  // dacƒÉ sesiunea a fost plƒÉtitƒÉ prin pachet
  packageSessionNumber Int?                       // numƒÉrul sesiunii din pachet (1, 2, 3...)

  // Rela»õii
  provider         Provider                @relation("ProviderSessions", fields: [providerId], references: [id], onDelete: Cascade)
  client           User                    @relation("ClientSessions", fields: [clientId], references: [id], onDelete: Cascade)
  sessionAccount   Account?                @relation("SessionAccount", fields: [accountId], references: [id], onDelete: SetNull)
  // üóëÔ∏è ELIMINAT: speciality       Speciality              @relation("SpecialitySessions", fields: [specialityId], references: [id], onDelete: Cascade)
  userPackage      UserProviderPackage?    @relation("SessionUserPackage", fields: [packageId], references: [id])
  
  // üÜï Rela»õie cu recenziile (o sesiune poate avea o recenzie)
  review           Review?                 @relation("SessionReview")

  // Legacy fields pentru compatibilitate (pot fi eliminate dupƒÉ migrare)
  accountId        Int?
  zoomSessionName  String?                 
  zoomTokens       Json?
  zoomCreatedAt    DateTime?
  zoomSessionId    String?

  // Timestamps cu valori default
  createdAt        DateTime                @default(now())
  updatedAt        DateTime                @default(now()) @updatedAt

  // Index-uri optimizate
  @@index([status])
  @@index([startDate])
  @@index([providerId, clientId])
  @@index([dailyRoomName])
  @@index([packageId, status])           // üÜï pentru cƒÉutƒÉri rapide dupƒÉ pachet »ôi status
  @@index([wasPackageSession])           // üÜï pentru filtrarea sesiunilor din pachete
  @@index([scheduledAt])                 // üÜï pentru sortarea cronologicƒÉ

  @@map("ConsultingSession")
}

// üîß MODEL REVIEW ACTUALIZAT CU LEGƒÇTURA DIRECTƒÇ LA SESIUNE
model Review {
  id           String    @id @default(uuid())
  comment      String?
  date         DateTime
  rating       Float
  service      Service   @default(MEET)

  // LegƒÉturile existente
  fromUserId   String
  fromUser     User      @relation("ReviewFromUser", fields: [fromUserId], references: [id], onDelete: Cascade)
  providerId   String
  provider     Provider  @relation("ReviewForProvider", fields: [providerId], references: [id], onDelete: Cascade)
  
  // üÜï LEGƒÇTURA DIRECTƒÇ CU SESIUNEA
  sessionId    String    @unique  // O sesiune = o recenzie maximƒÉ
  session      ConsultingSession @relation("SessionReview", fields: [sessionId], references: [id], onDelete: Cascade)

  // üÜï Index pentru cƒÉutƒÉri rapide
  @@index([fromUserId, providerId])      // cƒÉutare dupƒÉ client »ôi provider
  @@index([providerId, rating])          // pentru statistici provider
  @@index([sessionId])                   // cƒÉutare dupƒÉ sesiune (deja unique)
  @@index([date])                        // sortare cronologicƒÉ
}

model Account {
  id                 Int                   @id @default(autoincrement())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?               @db.Text
  access_token       String?               @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?               @db.Text
  session_state      String?

  user               User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  accountSessions    ConsultingSession[]   @relation("SessionAccount")

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  user         User     @relation("UserSessions", fields: [userId], references: [id], onDelete: Cascade)
  expires      DateTime
}

model GroupUsers {
  id         Int        @id @default(autoincrement())
  group      ChatGroup  @relation(fields: [group_id], references: [id], onDelete: Cascade)
  group_id   String
  user       User       @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id    String
  createdAt  DateTime   @default(now())
}

model ChatGroup {
  id         String     @id @default(uuid())
  user       User       @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id    String
  name       String
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  groupUsers GroupUsers[]
}

model CalendlyWebhookSubscription {
  id               String    @id @default(uuid())
  subscriptionId   String    @unique
  calendarUri      String
  events           String[]  
  scope            String
  callbackUrl      String
  providerId       String
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  provider         Provider  @relation("ProviderCalendlyWebhooks", fields: [providerId], references: [id], onDelete: Cascade)

  @@index([calendarUri])
}

model EmailVerification {
  id        String   @id @default(uuid())
  userId    String   @unique
  token     String   @unique
  expiresAt DateTime

  user      User     @relation("UserEmailVerification", fields: [userId], references: [id], onDelete: Cascade)
}

model PasswordReset {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
}